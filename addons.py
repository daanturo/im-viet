import itertools
import json
import os
import re
import shutil
import subprocess
import tempfile
import urllib.request
import zipfile
from pathlib import Path

import core


def compare_with_floris_telex():
    url = "https://raw.githubusercontent.com/florisboard/florisboard/refs/heads/main/app/src/main/assets/ime/keyboard/org.florisboard.composers/extension.json"
    floris_file = os.path.join(tempfile.gettempdir(), "floris-extension.json")
    generated_file = os.path.abspath("generated-im-telex.json")
    if not os.path.exists(floris_file):
        urllib.request.urlretrieve(url, filename=floris_file)
    # print(f"Comparing: '{generated_file}', '{floris_file}'")
    floris = [
        composer["rules"]
        for composer in json.loads(Path(floris_file).read_text())["composers"]
        if composer.get("id") == "telex"
    ][0]
    # We handle d...d -> đ...
    generated = {
        k: v
        for (k, v) in json.loads(Path(generated_file).read_text()).items()
        if not re.search(r"^[dđ][^dđ]", k)
    }
    diff_lst = core.dict_diff(generated, floris)
    Path("generated-rules-diff-this-telex-vs-floris-telex.json").write_text(
        json.dumps(
            {
                "floris - this": diff_lst[1],
                "this - floris": diff_lst[0],
            },
            indent=2,
            ensure_ascii=False,
        )
    )


def write_emacs_quail_rules():
    """Problem with quail: after finishing a diacritic, typing more won't
    modify the word, unless exhaustively listing all variants.
    """
    rules = core.make_im_vni(core.get_full_rhyme_table())
    # Prioritize longer?
    keys = sorted(rules.keys(), key=lambda s: (-len(s), s))
    with open("temp-vn-vni-x.el", "w") as f:
        f.write(";; -*- lexical-binding: t -*-" + "\n\n")
        f.write("(require 'quail)\n\n")
        f.write("""
(quail-define-package
 "vietnamese-vni-x"              ; NAME
 "Vietnamese"                    ; LANGUAGE
 "VVX"                           ; TITLE
 t                               ; GUIDANCE
 "VNI input method, with Tan Ky mode on, allow user to type diacritical marks
 anywhere within a word and the marks will appear at their proper locations.
"                                ; DOCSTRING
 nil                             ; TRANSLATION-KEYS
 t                               ; FORGET-LAST-SELECTION
 nil                             ; DETERMINISTIC
 nil                             ; KBD-TRANSLATE
 nil                             ; SHOW-LAYOUT
 nil                             ; CREATE-DECODE-MAP
 nil                             ; MAXIMUM-SHORTEST
 nil                             ; OVERLAY-PLIST
 nil                             ; UPDATE-TRANSLATION-FUNCTION
 nil                             ; CONVERSION-KEYS
 t)
\n""")
        f.write("(quail-define-rules" + "\n")
        # No upper case handling yet
        for k in keys:
            v = rules[k]
            f.write(f' ("{k}"  ["{v}"])\n')
        f.write(")" + "\n")


def dict_to_emacs_hash_table(hmap: dict, indent=2) -> str:
    indent_str = " " * indent
    return (
        "#s(hash-table test equal data (\n"
        + "\n".join(
            [
                indent_str
                + f"{json.dumps(k, ensure_ascii=False)} {json.dumps(v, ensure_ascii=False)}"
                for (k, v) in hmap.items()
            ]
        )
        + "\n"
        + " " * (indent - 0)
        + "))"
    )


def write_emacs_package_rules_file():
    rhyme_table = core.get_full_rhyme_table()
    rules_vni = core.make_im_vni(rhyme_table)
    rules_telex = core.make_im_telex(rhyme_table)
    rules_file = "viet-im-rules.el"
    with open(rules_file, "w", encoding="utf8") as f:
        f.write(";; -*- lexical-binding: t -*-" + "\n\n")
        f.write(
            """
;; This file is automatically generated

(defvar viet-im--rules-table
  '((vni
            . """
            + dict_to_emacs_hash_table(rules_vni)
            + """)
    (telex
            . """
            + dict_to_emacs_hash_table(rules_telex)
            + """))
            "Association list of input method names (as symbols) and their rules (as hash tables).")

(defvar viet-im--prefix-consonants '("""
            + "\n".join(
                f'"{s}"'
                for s in (["qu", "gi"] + core.get_words_and_rhymes()["prefix_consonants"])
            )
            + """))

(defvar viet-im--suffix-consonants '("""
            + "\n".join(
                f'"{s}"' for s in (core.get_words_and_rhymes()["suffix_consonants"])
            )
            + """))

;;; viet-im-rules ends here

(provide 'viet-im-rules)

;; Local Variables:
;; coding: utf-8
;; End:"""
        )
    subprocess.run(
        [
            "emacs",
            "--batch",
            "--eval",
            f'(progn (find-file "{rules_file}") (indent-region (point-min) (point-max)) (save-buffer 0))',
        ]
    )


def write_floris_vni_extension():
    rules = core.make_im_vni()
    groups = core.group_rules_for_write(rules.keys())
    indent_str = " " * 8  # depend on inserting position below
    rules_str = (
        "\n".join(
            map(
                lambda g: indent_str
                + " ".join(map(lambda k: f'"{k}": "{rules[k]}",', g)),
                groups,
            )
        )
    ).removesuffix(",")
    # https://github.com/florisboard/florisboard/wiki/Creating-and-Packaging-Extensions
    # Happy to change the id to just "vni" if accepted upstream.
    extension_data = (
        """{
  "$": "ime.extension.keyboard",
  "meta": {
    "id": "io.github.daanturo.viet-im-rules.vni",
    "version": "0.1.0",
    "title": "Vietnamese VNI input method",
    "description": "Provide the Vietnamese (Tan Ky mode) VNI input method for Florisboard, in addition to the built-in Telex.\\n  See: https://en.wikipedia.org/wiki/VNI#Input_methods.",
    "keywords": ["composer", "input-method"],
    "maintainers": ["@daanturo"],
    "license": "mpl-2.0"
  },
  "composers": [
    {
      "$": "with-rules",
      "id": "vni-addon",
      "label": "VNI",
      "rules": {"""
        + "\n"
        + rules_str
        + """
      }
    }
  ]
}\n"""
    )
    non_zipped_extension_file = "floris-im-vni-extension.json"
    Path(non_zipped_extension_file).write_text(extension_data, encoding="utf8")
    # No idea how to generate a .flex archive file, none of the web searching,
    # Mistral, chatGPT, Gemini knew, until I did a org-wide search and stumbled
    # at
    # https://github.com/florisboard/nlp/blob/9e8d49649d6a3d32af85873043ba2c3c0a43d151/utils/convert_dictionaries_to_extensions.py#L56
    zipped_content = ""
    if os.path.exists("floris-im-vni-extension.flex"):
        with zipfile.ZipFile("floris-im-vni-extension.flex", "r") as zaf:
            with zaf.open("extension.json") as f:
                zipped_content = f.read().decode("utf8")
    if zipped_content != extension_data:
        with zipfile.ZipFile("floris-im-vni-extension.flex", "w") as zaf:
            zaf.write(non_zipped_extension_file, arcname="extension.json")
